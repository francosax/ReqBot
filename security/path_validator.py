"""
Path validation module for ReqBot.

Provides functions to validate user-provided paths for security and safety.
Prevents path traversal attacks and validates file system operations.
"""

import os
import logging
from pathlib import Path
from typing import Optional, List

logger = logging.getLogger(__name__)


class PathValidationError(Exception):
    """Raised when path validation fails."""
    pass


# Suspicious path patterns that should trigger warnings
SUSPICIOUS_PATH_PATTERNS = [
    'etc/passwd', 'etc/shadow', 'windows/system32', 'system32',
    '.ssh', 'id_rsa', 'authorized_keys', 'private_key',
    'windows/config', 'boot/', '/dev/', '/proc/', '/sys/'
]


def validate_safe_path(
    path: str,
    base_dir: Optional[str] = None,
    must_exist: bool = True,
    allowed_extensions: Optional[List[str]] = None,
    path_type: str = 'file'  # 'file' or 'directory'
) -> Path:
    """
    Validate that a path is safe to use.

    This function provides security validation to prevent path traversal attacks
    and ensures paths are within allowed directories.

    Args:
        path: User-provided path to validate
        base_dir: Optional base directory to restrict path to
        must_exist: Whether the path must exist (default: True)
        allowed_extensions: List of allowed file extensions (e.g., ['.pdf', '.xlsx'])
        path_type: Expected path type - 'file' or 'directory'

    Returns:
        Validated absolute Path object

    Raises:
        PathValidationError: If path is invalid or unsafe

    Example:
        >>> safe_path = validate_safe_path('/home/user/documents/spec.pdf',
        ...                                  allowed_extensions=['.pdf'])
        >>> print(safe_path)
        /home/user/documents/spec.pdf
    """
    # Basic validation
    if not path or not isinstance(path, str):
        raise PathValidationError("Path must be a non-empty string")

    # Convert to Path object and resolve to absolute path
    try:
        path_obj = Path(path).resolve()
    except (ValueError, OSError, RuntimeError) as e:
        raise PathValidationError(f"Invalid path format: {str(e)}")

    # Check if path exists
    if must_exist and not path_obj.exists():
        raise PathValidationError(f"Path does not exist: {path}")

    # Check path type if it exists
    if path_obj.exists():
        if path_type == 'file' and not path_obj.is_file():
            raise PathValidationError(f"Expected a file, but got a directory: {path}")
        elif path_type == 'directory' and not path_obj.is_dir():
            raise PathValidationError(f"Expected a directory, but got a file: {path}")

    # Check if path is within base directory (prevents path traversal)
    if base_dir:
        try:
            base_path = Path(base_dir).resolve()
            # Check if path is relative to base_path
            try:
                path_obj.relative_to(base_path)
            except ValueError:
                raise PathValidationError(
                    f"Path '{path}' is outside allowed directory '{base_dir}'. "
                    "Path traversal attempts are not allowed."
                )
        except (OSError, RuntimeError) as e:
            raise PathValidationError(f"Invalid base directory: {str(e)}")

    # Check file extension for files
    if allowed_extensions and (path_obj.is_file() or path_type == 'file'):
        if path_obj.suffix.lower() not in [ext.lower() for ext in allowed_extensions]:
            raise PathValidationError(
                f"Invalid file extension: {path_obj.suffix}. "
                f"Allowed extensions: {', '.join(allowed_extensions)}"
            )

    # Check for suspicious patterns
    path_str_lower = str(path_obj).lower().replace('\\', '/')
    for pattern in SUSPICIOUS_PATH_PATTERNS:
        if pattern in path_str_lower:
            logger.warning(f"Suspicious path pattern detected: {pattern} in {path}")
            raise PathValidationError(
                f"Path contains suspicious pattern: {pattern}. "
                "Access to system directories is not allowed."
            )

    # Additional checks for Windows paths
    if os.name == 'nt':  # Windows
        # Check for UNC paths that might be problematic
        if str(path_obj).startswith('\\\\'):
            logger.warning(f"UNC path detected: {path}")
            # Allow UNC paths but log them

    return path_obj


def validate_output_path(
    path: str,
    allowed_extensions: Optional[List[str]] = None,
    check_writable: bool = True,
    allow_overwrite: bool = True
) -> Path:
    """
    Validate that an output path is safe to write to.

    Ensures the output directory exists, is writable, and the file extension
    is allowed. Does not check for suspicious patterns as strictly as input
    paths since these are generated by the application.

    Args:
        path: Output file path
        allowed_extensions: List of allowed file extensions
        check_writable: Whether to check if directory is writable
        allow_overwrite: Whether to allow overwriting existing files

    Returns:
        Validated Path object

    Raises:
        PathValidationError: If path is unsafe

    Example:
        >>> output_path = validate_output_path('/home/user/output/report.xlsx',
        ...                                      allowed_extensions=['.xlsx'])
        >>> print(output_path)
        /home/user/output/report.xlsx
    """
    # Basic validation
    if not path or not isinstance(path, str):
        raise PathValidationError("Output path must be a non-empty string")

    # Convert to Path
    try:
        path_obj = Path(path).resolve()
    except (ValueError, OSError, RuntimeError) as e:
        raise PathValidationError(f"Invalid output path format: {str(e)}")

    # Check parent directory exists
    parent = path_obj.parent
    if not parent.exists():
        raise PathValidationError(
            f"Output directory does not exist: {parent}. "
            "Please create the directory first."
        )

    # Check parent directory is writable
    if check_writable:
        if not os.access(parent, os.W_OK):
            raise PathValidationError(
                f"No write permission for directory: {parent}"
            )

    # Validate extension
    if allowed_extensions:
        if path_obj.suffix.lower() not in [ext.lower() for ext in allowed_extensions]:
            raise PathValidationError(
                f"Invalid output file extension: {path_obj.suffix}. "
                f"Allowed extensions: {', '.join(allowed_extensions)}"
            )

    # Check if file exists (for overwrite checking)
    if not allow_overwrite and path_obj.exists():
        raise PathValidationError(
            f"File already exists and overwrite is not allowed: {path}"
        )

    # Check for suspicious patterns in output paths too
    path_str_lower = str(path_obj).lower().replace('\\', '/')
    critical_patterns = ['etc/passwd', 'etc/shadow', 'windows/system32', 'system32']
    for pattern in critical_patterns:
        if pattern in path_str_lower:
            raise PathValidationError(
                f"Cannot write to system directory: {pattern} detected in path"
            )

    return path_obj


def sanitize_path_for_logging(path: str) -> str:
    """
    Sanitize a file path for safe logging.

    Removes potentially sensitive information from paths (like usernames)
    while keeping enough information for debugging.

    Args:
        path: Full file path

    Returns:
        Sanitized path suitable for logging

    Example:
        >>> sanitized = sanitize_path_for_logging('/home/john/secret/document.pdf')
        >>> print(sanitized)
        .../secret/document.pdf
    """
    try:
        path_obj = Path(path)

        # For absolute paths, show only the last 2 components
        if path_obj.is_absolute():
            parts = path_obj.parts
            if len(parts) > 2:
                # Show last 2 parts (directory + filename)
                return f".../{parts[-2]}/{parts[-1]}"
            else:
                return str(path_obj.name)
        else:
            # For relative paths, just return the filename
            return str(path_obj.name)

    except Exception:
        # If anything goes wrong, just return the filename
        return os.path.basename(path) if path else "unknown"


def validate_batch_paths(
    paths: List[str],
    base_dir: Optional[str] = None,
    allowed_extensions: Optional[List[str]] = None,
    path_type: str = 'file'
) -> List[Path]:
    """
    Validate multiple paths at once.

    Args:
        paths: List of paths to validate
        base_dir: Optional base directory to restrict paths to
        allowed_extensions: List of allowed file extensions
        path_type: Expected path type - 'file' or 'directory'

    Returns:
        List of validated Path objects

    Raises:
        PathValidationError: If any path is invalid
    """
    validated_paths = []
    errors = []

    for i, path in enumerate(paths):
        try:
            validated = validate_safe_path(
                path,
                base_dir=base_dir,
                allowed_extensions=allowed_extensions,
                path_type=path_type
            )
            validated_paths.append(validated)
        except PathValidationError as e:
            errors.append(f"Path {i+1} ({sanitize_path_for_logging(path)}): {str(e)}")

    if errors:
        raise PathValidationError(
            f"Validation failed for {len(errors)} path(s):\n" + "\n".join(errors)
        )

    return validated_paths


# Convenience function for common PDF validation
def validate_pdf_input(path: str, base_dir: Optional[str] = None) -> Path:
    """
    Validate a PDF input file path.

    Args:
        path: Path to PDF file
        base_dir: Optional base directory to restrict to

    Returns:
        Validated Path object

    Raises:
        PathValidationError: If path is invalid
    """
    return validate_safe_path(
        path,
        base_dir=base_dir,
        must_exist=True,
        allowed_extensions=['.pdf', '.PDF'],
        path_type='file'
    )


# Convenience function for common Excel validation
def validate_excel_template(path: str) -> Path:
    """
    Validate an Excel template file path.

    Args:
        path: Path to Excel template file

    Returns:
        Validated Path object

    Raises:
        PathValidationError: If path is invalid
    """
    return validate_safe_path(
        path,
        must_exist=True,
        allowed_extensions=['.xlsx', '.XLSX'],
        path_type='file'
    )


# Convenience function for directory validation
def validate_directory(path: str, must_exist: bool = True, check_writable: bool = False) -> Path:
    """
    Validate a directory path.

    Args:
        path: Directory path
        must_exist: Whether directory must exist
        check_writable: Whether to check write permissions

    Returns:
        Validated Path object

    Raises:
        PathValidationError: If path is invalid
    """
    path_obj = validate_safe_path(
        path,
        must_exist=must_exist,
        path_type='directory'
    )

    if check_writable and path_obj.exists():
        if not os.access(path_obj, os.W_OK):
            raise PathValidationError(f"Directory is not writable: {path}")

    return path_obj
